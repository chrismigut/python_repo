The test file has to start with test_ for pytest
==================
import pytest
import [function to test]

def test_for_result_with_message():
    input = ""
    actual = function(input)
    expected = ""
    message = (
        "function(input)"
        "return {0} instead of {1}.format(actual, expected)
    )

    assert actual is expected, message

==================
To run pytest in terminal
> pytest testFile.py

To see inside a test file for terminal
> cat testFile.py

==================
How to compare flouts
Use pytest.approx() to wrap the expected return value

assert np.array([0.1]) == pytest.approx(np.array[0.1])
==================
To check types use isinstance(actual, type)
==================
Test for exceptions

with pytest.raises("place error to test for here")
    code to test

example:
with pytest.raises(ValueError)
    sampleCode()

if code does not raise that expected error,
then the test will fail and another type of error is thrown


#Test for exception
with pytest.raises(ValueError) as exception_info # store the exception_info
    sampleCode()

#Check for correct message return
assert exception_info.match("some string")
***************
import numpy as np
import pytest
from train import split_into_training_and_testing_sets

def test_on_one_row():
    test_argument = np.array([[1382.0, 390167.0]])
   
    # Store information about raised ValueError in exc_info
    with pytest.raises(ValueError) as exc_info:
      split_into_training_and_testing_sets(test_argument)
    expected_error_msg = "Argument data_array must have at least 2 rows, it actually has just 1"
    
    # Check if the raised ValueError contains the correct message
    assert exc_info.match(expected_error_msg)
***************
Stop tests on first failure
> pytest -x 

Run a subset of tests
> pytest data/test_module.py

Run only a single test
> pytest data/test_module.py::TestFunctionClass
> pytest data/test_module.py::TestFunctionClass::test_something

To run test with more power use -k
> pytest -k "pattern"

Test class
> pytest -k "TestFunctionClass"

Run all test but this one in this class
> pytest -k "TestFunctionClass and not test_something"
***************
If you need to ignore a test, use xfail

import pytest

class TestClass(object):

    @pytest.mark.xfail
    def test_something(self):
        pass

@pytest.mark.xfail(reason="Using TDD, model_test() has not yet been implemented")

***************
Ignore errors on a conditional, expected failures
* not supported python version
* some os version, etc

import pytest

class TestClass(object):

    @pytest.mark.skipif(boolean_expression)
    def test_something(self):
        pass

example: support python version 3.0 or higher
import sys
import pytest

class TestClass(object):

    @pytest.mark.skipif(sys.version_info < (3, 0), reason="only python 3.o or higher supported")
    def test_something(self):
        pass
 
show reason why tests where skipped
> !pytest -rs 
-r reason
-s skipped